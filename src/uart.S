.global main
/*
Данные UART как для отправки так и для получения читаем/записываем в регистр UARTDR
логика работы:
	1. Настраиваем UART0
	2. ждем получения данных в входной FIFO буфер UART проверяя флаг RXFE (буфер пустой)
	3. сохраняем полученное значение в r0 из UARTDR
	4. проверяем входной FIFO буфер что он не полный, флаг TXFF (буфер полный)
	5. записываем содержимое r0 в входной буфер FIFO (через UARTDR)
	6. повторяем с 2 пункта 
*/
.equ RESETS_BASE,	0x4000c000	// Базовый адрес инициализации МK (datasheet 2.2.2)
.equ UART0_BASE,	0x40034000	// Базовый адрес регистров UART0 (datasheet 2.2.2)
.equ CLOCKS_BASE, 	0x40008000  // Базовый адрес регистров тактовых импульсов (datasheet 2.2.2)
.equ IO_BANK0_BASE,	0x40014000  // Базовый адрес регистров IO_BANK0 (datasheet 2.2.2) 
.equ RESET_SET,		0x2000		// смещение на атомарные регистры установки сброса MK (datasheet 2.1.2)
.equ RESET_CLR,		0x3000		// смещение на атомарные регистры обнуления сброса МК (datasheet 2.1.2)
.equ RESET_DONE,	0x8			// номер бита проверки инициализации
.equ RESET_UART0,	22			// номер бита для инициализации UART (datasheet 2.14.3)
.equ UARTFR,		0x18		// регистр флагов UART (datasheet 4.2.8)
.equ UARTCR,		0x30		// регистр управления UART (datasheet 4.2.8)
.equ UARTIBRD, 		0x24		// регистр настройки битрейта UART целая часть числа из формулы (datasheet 4.2.8)
.equ UARTFBRD,		0x28		// регистр настройки битрейта UART дробная часть числа из формулы (datasheet 4.2.8)
.equ UARTLCR_H,		0x2c		// регистр настройки формата данных (datasheet 4.2.8)
.equ CLK_PERI_CTRL,	0x48		// регистр настройки тактовых импульсов (datasheet 2.15.7)
.equ GPIO0_CTRL,	0x4			// регистр настройки GPIO0 (datasheet 2.19.6.1)
.equ GPIO1_CTRL,	0xc			// регистр настройки GPIO1 (datasheet 2.19.6.1)

main:

// *****************************************
// настройка UART 

// Инициализация UART
/*  Я вот написал комментарий для RESET_SET и RESET_CLR, но как то не по русски получилось :)
	суть работы в следующем. Необходимо установить нужный бит для устройства в регистре со смещением RESET_SET
	затем установить нужный бит для устройства в регистре со смещением RESET_CLR (какой бит за какую перифирию отвечает смотрим в datasheet 2.14.3)
	затем дождаться иициализации устройства проверяя бит RESET_DONE в регистре по адресу RESETS_BASE
*/
	ldr r0, =RESETS_BASE		//Базовый адрес регистра инициализации 
	ldr	r1, =RESET_SET			//смещение на адрес RESET_SET  
	mov r2, #1			  		//Загружаем 1 в бит 0
	lsl r2, r2, #RESET_UART0	//Смещаем в 22 бит (можно было бы сразу записать значение, но мне лень считать :) Пусть МК сам найдет)
	str r2, [r0, r1]	  		//Записываем 22бит в нужный регистр	(RESETS_BASE+RESET_SET)

// Вывести UART0 из режима сброса (отменить сброс)
	ldr r1, =RESET_CLR 			//смещение на адрес RESET_CLR 
	str r2, [r0, r1]			//записываем 22бит в регистр (RESETS_BASE+RESET_CLR)

// Проверяем что UART0 инициализировался
uart_no_reset:     
	ldr r1, [r0, #RESET_DONE]	// получаем данные из регистра RESET_DONE 
	tst r1, r2					// проверяем 22 бит
	beq uart_no_reset			// если бит 22 равен 0 переходим по метке, иначе инициализация прошла успешно идем дальше 

//Установка генератора тактовых импульсов для uart в качестве генератора импильсов возьмем XOSC(12мГц) AUXSRC = 0x4 как наиболее стабильный 
	ldr r0, =CLOCKS_BASE   		// Базовый адрес регистров тактовых импульсов
	mov r1, #1 		  			// r1 <= #0b100010000000
	lsl r1, r1, #11	  		    // регистр CLK_PERI_CTRL (11 бит - ENABLE, и 7:5 биты - AUXSRC)
	add r1, #128	  		    // ENABLE - включает генератор, AUXSRC - выбор источника импульсов (datasheet 2.15.7)
	str r1, [r0,#CLK_PERI_CTRL]	// запишем данные в регистр CLK_PERI_CTRL		

// Включаем UART0 на прием и передачу
	ldr r0, =UART0_BASE  		// Базовый регистр UART0
	mov r1, #3					// r1 <=  #0b1100000001 
	lsl r1, #8					// Необходимо установить 3 бита (9 бит - RXE, 8 бит - TXE, 0 бит - UARTEN)
	add r1, #0x01				// (разрешение приема, отправки и самого uart) 
	str r1, [r0, #UARTCR]  		// сохраняем значение в регистре UARTCR

// Установка битрейта UART0 (datasheet 4.2.7.1)
// BaudRate: 115200; UARTCLK: 12MHz (datasheet 2.16.1)
// (UARTCLK)/(16*BaudRate)~=6.5104; BRDI=6, BRDF=0.5104, m=integer((0.514*64)+0.5)=33
	mov r1, #6	  				// BRDI
	str r1, [r0, #UARTIBRD]  	// сохраняем в регистр UARTIBRD
	mov r1, #33			  		// m
	str r1, [r0, #UARTFBRD]		// сохраняем в регистр UARTFBRD
	
// Установка формата данных 8,n,1 включение FIFO
	mov r1, #0b01110000			// подробности в datasheet (4.2.8)
	str r1, [r0, #UARTLCR_H]  	// сохраняем данные

// настройка GPIO0 и GPIO1 для UART0
	ldr r0, =IO_BANK0_BASE		// Базовый адрес IO_BANK0
	mov r1, #2			  		// функция 2 UART0_TX & UART0_RX  (datasheet 2.19.2)
	str r1, [r0, #GPIO0_CTRL]	// сохраняем функцию 2 в GPIO0_CTRL
	str r1, [r0, #GPIO1_CTRL]   // сохраняем функцию 2 в GPIO1_CTRL	

// Базовый адрес UART0 в r1
ldr r1, =UART0_BASE 	// Базовый регистр UART0

// Основная программа приема и передачи по UART
uart0_loop:
	bl uart0_in				// получим данные по UART (данные в r0)
	bl uart0_out			// отправим данные по UART (данные в r0)
	b uart0_loop			// зацикливаем программу 

uart0_out:
	push {r2,r3,lr}			// Сохраняем в стек
uart0_out_loop:		
	ldr r2, [r1, #UARTFR]	// прочитаем флаги UART0
	mov r3, #0x20			// будем проверять пятый бит (TX FIFO full TXFF)
	tst r2, r3				// Посмотрим чему равен пятый бит
	bne uart0_out_loop		// если буфер отправки FIFO полный (TXFF = 1), уходим по метке (ждем отправления данных по UART)
	mov r2, #0xff			// установим маску 0xff
	and r0, r2				// возьмем младшие 8 бит для отправки
	str r0, [r1, #0]		// сохраним данные в UARTDR
	pop {r2,r3,pc}	 		// Востановим регистры из стека и возврат из функции
	
uart0_in:
	push {r2,r3,lr}			// Сохраняем регистры в стек
uart0_in_loop:	
	ldr r2, [r1, #UARTFR] 	// прочитаем флаги UART0
	mov r3, #0x10	 		// будем проверять четвертый бит (RX FIFO empty RXFE)
	and r2, r3		 		// посмотрим чему равен четвертый бит
	bne uart0_in_loop	 	// если буфер приема FIFO пустой (RXFE = 1), уходим по метке (ждем данные от внешнего устройства)
	ldr r0, [r1, #0]	  	// загрузим в регистр r0
	pop {r2,r3,pc}			// Востановим регистры из стека и возврат из функции
